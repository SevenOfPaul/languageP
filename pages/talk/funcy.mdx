import Answer from "@/components/Answer"
export const AnsContent = () => {
    return (
        <div className="prose dark:prose-invert max-w-none">
          <p className='h3'>历史原因</p>
          <p>
                lambda 演算的起源深受数学逻辑的影响，特别是函数概念的形式化。在数学中，函数通常被定义为一种映射关系，对于给定的输入，总是产生相同的输出，这种映射关系是稳定且不变的。lambda 表达式作为函数式编程的基础，借鉴了这种数学上的函数概念，强调函数的输出仅由输入决定，
          </p>
            <p>
               早期的计算机科学正处于发展初期，需要建立简洁、清晰的计算模型来理解和构建计算系统。不可变的 lambda 表达式有助于构建这样的模型。不可变性使得 lambda 表达式的求值过程更加简单和直观。由于表达式中的变量值一旦确定就不再改变，在对 lambda 表达式进行归约（求值）操作时，不需要考虑变量值被其他操作修改的情况，从而可以更方便地对表达式进行形式化分析和推导，
            </p>
        </div>
    )
}

# 函数式编程
+ 函数是编程传承自数学，通过函数抽象和应用的机制，能表示各种复杂的计算过程。任何可计算函数都可以用 lambda 表达式来表示，它能对函数进行定义、组合和嵌套，实现各种逻辑和算法。
## 不可变
+ 严格意义上讲，函数式的输入和输出是固定的，且**不修改外部状态**，什么意思呢？。
```c
int a=1;
int multiple(int a,int b){
 return a*b
}
multiple(a,2) 
```
+ 现在我们要修改a的值，传承自函数式思想要求我们
```c
a=multiple(a,2) 
//而非
void multiple(int *a, int b) {
    *a = *a * b; //修改外部状态
}
```
+ 可能这里有点不太好理解。那我们联系下实际，`setSate`是个什么样的函数呢？
<Answer title="为什么要有不可变" content={<AnsContent/>} author="paul" />
## 函数式的核心是函数的组合