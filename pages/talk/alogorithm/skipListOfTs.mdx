import { Image } from 'nextra/components'
import Link from 'next/link'

# 跳表
<Link href="https://leetcode.cn/problems/design-skiplist/" className="h2">设计跳表</Link>
+ 粗暴的说 跳表就是一张二维表 这张表用二分的思想把所有的元素的`半`存了起来 方便我们查询
+ 所以相交于传统的n的时间复杂度 降到了logn
+ 但是空间复杂度 也上升了 因为我们需要把所有的元素的`半`存起来
+ 所以跳表的空间复杂度 是nlogn
<Image src="/imgs/skipList.png" className='w-full'/>
+ 理论上用二维数组也可以编写 但是我门还是采用数组+链表的形式 因为简单
+ 同样 这次使用ts来实现 放弃rust, rust写这个<span className='bold'>不用unsafe得死！</span>
```
//创建node 里面存储一个值 和一个数组保存 半 值
class TNode {
  val: number
  next: TNode[];
  constructor(_val: number,level:number) {
      this.val = _val
      this. next: TNode[] = new Array<TNode>(level)
  } 
}
```
+ 我们需要一个level 来确定当前层级 因为主要是写lc 所以设置为10
+ 实际使用的话 可以使用设计的最大容量来折算 maxLevel=log₂n
+ 同时为了方便处理 我们使用-1作为头结点 
```
class Skiplist {
  he: TNode = new TNode(-1)
      level: number = 10
}
```
+ 下面是各个函数的编写
```
 find(t: number): Array<TNode> {
      let cur = this.he
      let ns: TNode[] = new Array<TNode>(this.level)
      for (let i = this.level - 1; i >= 0; i--) {
          while (cur.next[i] != null && cur.next[i].val < t){
            cur = cur.next[i];
          }
          ns[i] = cur;
      }
      return ns
  }
  search(t: number): boolean {
     let ns= this.find(t)
      return ns[0].next[0] != null && ns[0].next[0].val == t
  }
  add(t: number): void {
    let ns= this.find(t)
      const node = new TNode(t,this.level)
      for (let i = 0; i < this.level; i++) {
          node.next[i] = ns[i].next[i]
          ns[i].next[i] = node
          if (Math.round(Math.random()) == 0) break
      }
  }
  erase(t: number): boolean {
    let ns= this.find(t)
      const node = ns[0].next[0]
      if (node == null || node.val != t) return false
      for (let i = 0; i < this.level && ns[i].next[i] == node; i++){
        ns[i].next[i] = ns[i].next[i].next[i]
      }
      return true
  }
```